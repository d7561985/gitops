# GitLab CI/CD Pipeline Template for {{SERVICE_NAME}}
# Pull-based GitOps with ArgoCD
#
# Flow: CI builds image → updates .cicd/{env}.yaml → ArgoCD syncs
#
# Replace all {{SERVICE_NAME}} with your actual service name
#
# Required CI/CD Variables (set at Group level):
#   CI_PUSH_TOKEN     - Group Access Token with write_repository scope
#   ARGOCD_SERVER     - ArgoCD server URL (e.g., argocd.demo-poc-01.work)
#   ARGOCD_AUTH_TOKEN - ArgoCD API token for ci-readonly account

variables:
  SERVICE_NAME: "{{SERVICE_NAME}}"

  # Docker registry (GitLab Container Registry)
  REGISTRY: ${CI_REGISTRY}
  IMAGE_NAME: ${CI_REGISTRY_IMAGE}

  # Helm chart
  HELM_CHART: "k8app/app"
  HELM_REPO: "https://d7561985.github.io/k8app"

  # ArgoCD settings for release tracking
  ARGOCD_OPTS: "--grpc-web"
  RELEASE_TIMEOUT: "300"

stages:
  - build
  - update-manifests
  - release

# ============================================
# Release Template: Wait for ArgoCD deployment
# ============================================
.release-template:
  stage: release
  image: alpine:3.19
  variables:
    ARGOCD_VERSION: "v2.13.2"
  before_script:
    - apk add --no-cache curl
    - curl -sSL -o /usr/local/bin/argocd "https://github.com/argoproj/argo-cd/releases/download/${ARGOCD_VERSION}/argocd-linux-amd64"
    - chmod +x /usr/local/bin/argocd
  script:
    - echo "Waiting for ${ARGOCD_APP_NAME} to sync and become healthy..."
    - echo "ArgoCD Server - ${ARGOCD_SERVER}"
    - echo "Timeout - ${RELEASE_TIMEOUT}s"
    - argocd app get ${ARGOCD_APP_NAME} --refresh ${ARGOCD_OPTS} > /dev/null
    - argocd app wait ${ARGOCD_APP_NAME} --timeout ${RELEASE_TIMEOUT} --health --sync ${ARGOCD_OPTS}
    - echo "RELEASE SUCCESSFUL"
    - argocd app get ${ARGOCD_APP_NAME} ${ARGOCD_OPTS} || true

# ============================================
# Build Stage
# ============================================
# For Go services with private modules:
#   docker build --build-arg GITLAB_TOKEN=${CI_PUSH_TOKEN} ...
#
# For Angular/Node.js with private npm git dependencies (BuildKit secrets):
#   IMPORTANT: Use CI_PUSH_TOKEN, not CI_JOB_TOKEN!
#   CI_JOB_TOKEN doesn't have cross-project access to api/gen/* repos.
#   echo "$CI_PUSH_TOKEN" > /tmp/gitlab_token
#   docker build --secret id=gitlab_token,src=/tmp/gitlab_token ...
#   rm -f /tmp/gitlab_token
# ============================================

build:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_BUILDKIT: "1"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    # For services with private dependencies, uncomment one of:
    # Go: docker build --build-arg GITLAB_TOKEN=${CI_PUSH_TOKEN} -t ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} .
    # Angular/Node.js (use CI_PUSH_TOKEN for cross-project access):
    #   echo "$CI_PUSH_TOKEN" > /tmp/gitlab_token
    #   docker build --secret id=gitlab_token,src=/tmp/gitlab_token -t ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} .
    #   rm -f /tmp/gitlab_token
    - docker build -t ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} .
    - docker push ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}
    # Tag as latest for main branch
    - |
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} ${IMAGE_NAME}:latest
        docker push ${IMAGE_NAME}:latest
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ============================================
# Pull-based GitOps: Update manifests
# ============================================

# Pull-based: Update .cicd/*.yaml and push back to repo
# Requires CI_PUSH_TOKEN (Group Access Token with write_repository scope)
# See README.md for setup instructions
.update-manifest:
  stage: update-manifests
  image: alpine:3.19
  before_script:
    - apk add --no-cache git yq
    - git config --global user.email "ci@gitlab.com"
    - git config --global user.name "GitLab CI"
    # Clone with push token (CI_JOB_TOKEN doesn't have push rights)
    - git remote set-url origin "https://oauth2:${CI_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch origin ${CI_COMMIT_BRANCH}
    - git checkout ${CI_COMMIT_BRANCH}
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

update:dev:
  extends: .update-manifest
  script:
    - |
      echo "Updating dev environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/dev.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/dev.yaml

      git add .cicd/dev.yaml
      git commit -m "ci(dev): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}

      echo "ArgoCD will detect this change and deploy automatically"

update:staging:
  extends: .update-manifest
  script:
    - |
      echo "Updating staging environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/staging.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/staging.yaml

      git add .cicd/staging.yaml
      git commit -m "ci(staging): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}
  when: manual
  needs:
    - update:dev

update:prod:
  extends: .update-manifest
  script:
    - |
      echo "Updating prod environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/prod.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/prod.yaml

      git add .cicd/prod.yaml
      git commit -m "ci(prod): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}
  when: manual
  needs:
    - update:staging

# ============================================
# Release Stage: Wait for ArgoCD deployment
# ============================================

release:dev:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-dev
  environment:
    name: dev
  needs:
    - job: update:dev
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

release:staging:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-staging
  environment:
    name: staging
  needs:
    - job: update:staging
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  when: manual

release:prod:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-prod
  environment:
    name: production
  needs:
    - job: update:prod
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  when: manual
