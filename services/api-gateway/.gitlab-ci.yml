# GitLab CI/CD Pipeline for api-gateway
# Pull-based GitOps with ArgoCD
#
# Flow: CI builds image → updates .cicd/{env}.yaml → ArgoCD syncs
#
# Required CI/CD Variables (set at Group level):
#   CI_PUSH_TOKEN     - Group Access Token with write_repository scope
#   ARGOCD_SERVER     - ArgoCD server URL (e.g., argocd.demo-poc-01.work)
#   ARGOCD_AUTH_TOKEN - ArgoCD API token for ci-readonly account

variables:
  SERVICE_NAME: "api-gateway"
  IMAGE_NAME: ${CI_REGISTRY_IMAGE}
  ARGOCD_OPTS: "--grpc-web"
  RELEASE_TIMEOUT: "300"

stages:
  - build
  - update-manifests
  - release

# ============================================
# Release Template: Wait for ArgoCD deployment
# ============================================
.release-template:
  stage: release
  image: alpine:3.19
  variables:
    ARGOCD_VERSION: "v3.2.1"
  before_script:
    - apk add --no-cache curl
    - |
      curl -fsSL --retry 3 --retry-delay 5 -o /usr/local/bin/argocd \
        "https://github.com/argoproj/argo-cd/releases/download/${ARGOCD_VERSION}/argocd-linux-amd64"
      chmod +x /usr/local/bin/argocd
      argocd version --client --short || { echo "ERROR: ArgoCD binary is invalid"; exit 1; }
  script:
    - echo "Waiting for ${ARGOCD_APP_NAME} to sync and become healthy..."
    - echo "ArgoCD Server - ${ARGOCD_SERVER}"
    - echo "Timeout - ${RELEASE_TIMEOUT}s"
    - argocd app get ${ARGOCD_APP_NAME} --server ${ARGOCD_SERVER} --auth-token ${ARGOCD_AUTH_TOKEN} --refresh ${ARGOCD_OPTS} --insecure > /dev/null
    - argocd app wait ${ARGOCD_APP_NAME} --server ${ARGOCD_SERVER} --auth-token ${ARGOCD_AUTH_TOKEN} --timeout ${RELEASE_TIMEOUT} --health --sync ${ARGOCD_OPTS} --insecure
    - echo "RELEASE SUCCESSFUL"
    - argocd app get ${ARGOCD_APP_NAME} --server ${ARGOCD_SERVER} --auth-token ${ARGOCD_AUTH_TOKEN} ${ARGOCD_OPTS} --insecure || true

# ============================================
# Build Stage
# ============================================
build:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} .
    - docker push ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}
    - |
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} ${IMAGE_NAME}:latest
        docker push ${IMAGE_NAME}:latest
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ============================================
# Update manifests (Pull-based GitOps)
# ============================================
.update-manifest:
  stage: update-manifests
  image: alpine:3.19
  before_script:
    - apk add --no-cache git yq
    - git config --global user.email "ci@gitlab.com"
    - git config --global user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${CI_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch origin ${CI_COMMIT_BRANCH}
    - git checkout ${CI_COMMIT_BRANCH}
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

update:dev:
  extends: .update-manifest
  script:
    - |
      echo "Updating dev environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/dev.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/dev.yaml

      git add .cicd/dev.yaml
      git commit -m "ci(dev): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}

update:staging:
  extends: .update-manifest
  script:
    - |
      echo "Updating staging environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/staging.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/staging.yaml

      git add .cicd/staging.yaml
      git commit -m "ci(staging): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}
  when: manual
  needs:
    - update:dev

update:prod:
  extends: .update-manifest
  script:
    - |
      echo "Updating prod environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/prod.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/prod.yaml

      git add .cicd/prod.yaml
      git commit -m "ci(prod): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}
  when: manual
  needs:
    - update:staging

# ============================================
# Release Stage: Wait for ArgoCD deployment
# ============================================
release:dev:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-dev
  environment:
    name: dev
  needs:
    - job: update:dev
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

release:staging:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-staging
  environment:
    name: staging
  needs:
    - job: update:staging
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  when: manual

release:prod:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-prod
  environment:
    name: production
  needs:
    - job: update:prod
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  when: manual
