# GitLab CI/CD Pipeline for web-grpc
# Pull-based GitOps with ArgoCD
#
# Flow: CI builds image → updates .cicd/{env}.yaml → ArgoCD syncs
#
# Required CI/CD Variables (set at Group level):
#   CI_PUSH_TOKEN     - Group Access Token with write_repository scope
#   ARGOCD_SERVER     - ArgoCD server URL (e.g., argocd.demo-poc-01.work)
#   ARGOCD_AUTH_TOKEN - ArgoCD API token for ci-readonly account

variables:
  SERVICE_NAME: "web-grpc"
  IMAGE_NAME: ${CI_REGISTRY_IMAGE}
  RELEASE_TIMEOUT: "300"

stages:
  - build
  - update-manifests
  - release

# ============================================
# Release Template: Wait for ArgoCD deployment
# Uses REST API instead of gRPC (CloudFlare compatible)
# ============================================
.release-template:
  stage: release
  image: alpine:3.19
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      echo "Waiting for ${ARGOCD_APP_NAME} to sync and become healthy..."
      echo "ArgoCD Server: https://${ARGOCD_SERVER}"
      echo "Timeout: ${RELEASE_TIMEOUT}s"

      ARGOCD_API="https://${ARGOCD_SERVER}/api/v1/applications/${ARGOCD_APP_NAME}"
      AUTH_HEADER="Authorization: Bearer ${ARGOCD_AUTH_TOKEN}"

      # Trigger refresh
      curl -sf "${ARGOCD_API}?refresh=normal" -H "${AUTH_HEADER}" > /dev/null || true

      # Wait for sync and health
      start_time=$(date +%s)
      while true; do
        response=$(curl -sf "${ARGOCD_API}" -H "${AUTH_HEADER}" 2>/dev/null)
        if [ $? -ne 0 ]; then
          echo "ERROR: Failed to get application status"
          exit 1
        fi

        sync_status=$(echo "$response" | jq -r '.status.sync.status // "Unknown"')
        health_status=$(echo "$response" | jq -r '.status.health.status // "Unknown"')

        echo "Status: sync=${sync_status}, health=${health_status}"

        if [ "$sync_status" = "Synced" ] && [ "$health_status" = "Healthy" ]; then
          echo ""
          echo "=== RELEASE SUCCESSFUL ==="
          echo "Application: ${ARGOCD_APP_NAME}"
          echo "Sync: ${sync_status}"
          echo "Health: ${health_status}"
          exit 0
        fi

        elapsed=$(($(date +%s) - start_time))
        if [ $elapsed -ge ${RELEASE_TIMEOUT} ]; then
          echo "ERROR: Timeout after ${RELEASE_TIMEOUT}s"
          echo "Final status: sync=${sync_status}, health=${health_status}"
          exit 1
        fi

        sleep 5
      done

# ============================================
# Build Stage
# ============================================
build:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} .
    - docker push ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}
    - |
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} ${IMAGE_NAME}:latest
        docker push ${IMAGE_NAME}:latest
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ============================================
# Update manifests (Pull-based GitOps)
# ============================================
.update-manifest:
  stage: update-manifests
  image: alpine:3.19
  before_script:
    - apk add --no-cache git yq
    - git config --global user.email "ci@gitlab.com"
    - git config --global user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${CI_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch origin ${CI_COMMIT_BRANCH}
    - git checkout ${CI_COMMIT_BRANCH}
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

update:dev:
  extends: .update-manifest
  script:
    - |
      echo "Updating dev environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/dev.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/dev.yaml

      git add .cicd/dev.yaml
      git commit -m "ci(dev): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}

update:staging:
  extends: .update-manifest
  script:
    - |
      echo "Updating staging environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/staging.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/staging.yaml

      git add .cicd/staging.yaml
      git commit -m "ci(staging): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}
  when: manual
  needs:
    - update:dev

update:prod:
  extends: .update-manifest
  script:
    - |
      echo "Updating prod environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/prod.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/prod.yaml

      git add .cicd/prod.yaml
      git commit -m "ci(prod): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}
  when: manual
  needs:
    - update:staging

# ============================================
# Release Stage: Wait for ArgoCD deployment
# ============================================
release:dev:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-dev
  needs:
    - job: update:dev
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

release:staging:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-staging
  needs:
    - job: update:staging
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  when: manual

release:prod:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-prod
  needs:
    - job: update:prod
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  when: manual
