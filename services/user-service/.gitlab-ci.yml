# GitLab CI/CD Pipeline for user-service
# Pull-based GitOps with ArgoCD
#
# Required CI/CD Variables (set at Group level):
#   CI_PUSH_TOKEN     - Group Access Token with write_repository scope
#   ARGOCD_SERVER     - ArgoCD server URL (e.g., argocd.demo-poc-01.work)
#   ARGOCD_AUTH_TOKEN - ArgoCD API token for ci-readonly account

variables:
  SERVICE_NAME: "user-service"
  REGISTRY: ${CI_REGISTRY}
  IMAGE_NAME: ${CI_REGISTRY_IMAGE}
  HELM_CHART: "k8app/app"
  HELM_REPO: "https://d7561985.github.io/k8app"
  GITOPS_MODE: "pull"
  ARGOCD_OPTS: "--grpc-web"
  RELEASE_TIMEOUT: "300"

stages:
  - build
  - update-manifests
  - release

# ============================================
# Build Stage
# ============================================
build:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    # Build with CI_PUSH_TOKEN for private GitLab dependencies (cross-group access)
    - docker build --build-arg GITLAB_TOKEN=${CI_PUSH_TOKEN} -t ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} .
    - docker push ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}
    - |
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag ${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA} ${IMAGE_NAME}:latest
        docker push ${IMAGE_NAME}:latest
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ============================================
# Update manifests (Pull-based GitOps)
# ============================================
.update-manifest:
  stage: update-manifests
  image: alpine:3.19
  before_script:
    - apk add --no-cache git yq
    - git config --global user.email "ci@gitlab.com"
    - git config --global user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${CI_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch origin ${CI_COMMIT_BRANCH}
    - git checkout ${CI_COMMIT_BRANCH}
  rules:
    - if: $GITOPS_MODE == "pull" && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

update:dev:
  extends: .update-manifest
  script:
    - |
      echo "Updating dev environment to ${CI_COMMIT_SHORT_SHA}"
      yq -i '.image.tag = "'${CI_COMMIT_SHORT_SHA}'"' .cicd/dev.yaml
      yq -i '.image.repository = "'${IMAGE_NAME}'"' .cicd/dev.yaml

      git add .cicd/dev.yaml
      git commit -m "ci(dev): update image to ${CI_COMMIT_SHORT_SHA} [skip ci]"
      git push origin ${CI_COMMIT_BRANCH}

      echo "ArgoCD will detect this change and deploy automatically"

# ============================================
# Release Stage: Wait for ArgoCD deployment
# ============================================
.release-template:
  stage: release
  image: alpine:3.19
  variables:
    ARGOCD_VERSION: "v2.13.2"
  before_script:
    - apk add --no-cache curl
    - curl -sSL -o /usr/local/bin/argocd "https://github.com/argoproj/argo-cd/releases/download/${ARGOCD_VERSION}/argocd-linux-amd64"
    - chmod +x /usr/local/bin/argocd
  script:
    - echo "Waiting for ${ARGOCD_APP_NAME} to sync and become healthy..."
    - echo "ArgoCD Server - ${ARGOCD_SERVER}"
    - echo "Timeout - ${RELEASE_TIMEOUT}s"
    - argocd app get ${ARGOCD_APP_NAME} --refresh ${ARGOCD_OPTS} > /dev/null
    - argocd app wait ${ARGOCD_APP_NAME} --timeout ${RELEASE_TIMEOUT} --health --sync ${ARGOCD_OPTS}
    - echo "RELEASE SUCCESSFUL"
    - argocd app get ${ARGOCD_APP_NAME} ${ARGOCD_OPTS} || true

release:dev:
  extends: .release-template
  variables:
    ARGOCD_APP_NAME: ${SERVICE_NAME}-dev
  environment:
    name: dev
  needs:
    - job: update:dev
      optional: true
  rules:
    - if: $GITOPS_MODE == "pull" && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
